"""
D4 Dihedral Group Token System

The dihedral group D4 (symmetries of a square) has 8 elements:
- e: identity
- r, r², r³: rotations by 90°, 180°, 270°
- s: reflection across vertical axis
- sr, sr², sr³: reflection composed with rotations

This is the smallest non-abelian group requiring both:
1. Permutation routing (rotations permute corners)
2. Sign-flipping dynamics (reflections change orientation)

Representation:
Each element is represented as (rotation_power, has_reflection) where:
- rotation_power ∈ {0, 1, 2, 3}
- has_reflection ∈ {False, True}

Token indices 0-7 map to group elements, 8-10 are special tokens.
"""

import random
from typing import Tuple

from tasks.base import TokenSystem


# Type alias for D4 elements
D4Element = Tuple[int, bool]  # (rotation_power, has_reflection)


def d4_multiply(g1: D4Element, g2: D4Element) -> D4Element:
    """
    Multiply two D4 elements: g1 * g2 (left-to-right composition).

    Using the presentation: r⁴ = s² = e, srs = r⁻¹
    Which implies: sr^k = r^(-k)s

    Multiplication rules:
    - r^a * r^b = r^(a+b mod 4)
    - r^a * sr^b = sr^(a+b mod 4)
    - sr^a * r^b = sr^(a-b mod 4)
    - sr^a * sr^b = r^(a-b mod 4)
    """
    a, ref1 = g1
    b, ref2 = g2

    if not ref1 and not ref2:
        # r^a * r^b = r^(a+b)
        return ((a + b) % 4, False)
    elif not ref1 and ref2:
        # r^a * sr^b = sr^(a+b)
        return ((a + b) % 4, True)
    elif ref1 and not ref2:
        # sr^a * r^b = sr^(a-b)
        return ((a - b) % 4, True)
    else:
        # sr^a * sr^b = r^(a-b)
        return ((a - b) % 4, False)


def d4_inverse(g: D4Element) -> D4Element:
    """Compute the inverse of a D4 element."""
    a, ref = g
    if not ref:
        # (r^a)^(-1) = r^(-a)
        return ((-a) % 4, False)
    else:
        # (sr^a)^(-1) = sr^a (reflections are self-inverse, sr^a * sr^a = r^0 = e)
        return (a, True)


def element_to_string(g: D4Element) -> str:
    """Convert D4 element to readable string."""
    a, ref = g
    if not ref:
        if a == 0:
            return "e"
        elif a == 1:
            return "r"
        else:
            return f"r{a}"
    else:
        if a == 0:
            return "s"
        elif a == 1:
            return "sr"
        else:
            return f"sr{a}"


class D4TokenSystem(TokenSystem):
    """
    Token system for D4 dihedral group.

    Token layout:
    - 0-7: Group elements (e, r, r², r³, s, sr, sr², sr³)
    - 8: BOS (begin-of-sequence)
    - 9: EOS (end-of-sequence)
    - 10: PAD (padding)

    Input format: [BOS, g_1, g_2, ..., g_k, EOS, PAD, PAD, ...]
    Output: class from 0-7 (the composed product)
    """

    # Special token indices
    BOS_IDX = 8
    EOS_IDX = 9
    PAD_IDX = 10

    def __init__(self):
        # Generate all 8 elements in canonical order
        # Order: e, r, r², r³, s, sr, sr², sr³
        self.all_elements: list[D4Element] = []
        for ref in [False, True]:
            for rot in range(4):
                self.all_elements.append((rot, ref))

        self.num_group_elements = 8
        self.num_tokens = 11  # 8 group elements + BOS + EOS + PAD

        # Bijections
        self.elem_to_idx = {elem: i for i, elem in enumerate(self.all_elements)}
        self.idx_to_elem = {i: elem for i, elem in enumerate(self.all_elements)}

        # Identity element
        self.identity_elem = (0, False)  # e
        self.identity_idx = self.elem_to_idx[self.identity_elem]

        # Precompute multiplication table for efficiency
        self._build_multiplication_table()

        # Store generators for restricted training
        self.generators = self._get_generators()

    def _build_multiplication_table(self):
        """Build 8x8 multiplication table."""
        self.mult_table = {}
        for i in range(self.num_group_elements):
            for j in range(self.num_group_elements):
                g1 = self.idx_to_elem[i]
                g2 = self.idx_to_elem[j]
                product = d4_multiply(g1, g2)
                self.mult_table[(i, j)] = self.elem_to_idx[product]

    def _get_generators(self) -> list[int]:
        """
        Return indices of standard generators for D4.
        D4 is generated by:
        - r = (1, False): 90° rotation
        - s = (0, True): reflection
        """
        r_idx = self.elem_to_idx[(1, False)]  # r
        s_idx = self.elem_to_idx[(0, True)]   # s
        return [r_idx, s_idx]

    def compose_indices(self, i: int, j: int) -> int:
        """Compose two group elements given their indices."""
        return self.mult_table[(i, j)]

    def compose_sequence(self, indices: list[int]) -> int:
        """Compose a sequence of group elements (left to right)."""
        result = self.identity_idx
        for idx in indices:
            result = self.compose_indices(result, idx)
        return result

    def scan_sequence(self, indices: list[int]) -> list[int]:
        """Return all prefix compositions: [g1, g1*g2, g1*g2*g3, ...]."""
        result = self.identity_idx
        scan = []
        for idx in indices:
            result = self.compose_indices(result, idx)
            scan.append(result)
        return scan

    def token_string(self, idx: int) -> str:
        """Convert token index to string representation."""
        if idx == self.BOS_IDX:
            return "<BOS>"
        elif idx == self.EOS_IDX:
            return "<EOS>"
        elif idx == self.PAD_IDX:
            return "<PAD>"
        else:
            return element_to_string(self.idx_to_elem[idx])

    def get_random_index(self) -> int:
        """Get a random group element index (0-7)."""
        return random.randint(0, self.num_group_elements - 1)

    def get_generator_index(self) -> int:
        """Get a random generator index (r or s)."""
        return random.choice(self.generators)

    def format_sequence(self, indices: list[int]) -> str:
        """Format a sequence of tokens for logging."""
        return " * ".join(self.token_string(i) for i in indices)

    def log_sample(self, indices: list[int], result_idx: int):
        """Log a sample with readable notation."""
        seq_str = self.format_sequence(indices)
        result_str = self.token_string(result_idx)
        print(f"  {seq_str} = {result_str}")


if __name__ == "__main__":
    # Test the token system
    ts = D4TokenSystem()

    print("D4 Token System")
    print("=" * 40)
    print(f"Elements: {ts.num_group_elements}")
    print(f"Tokens: {ts.num_tokens}")
    print(f"Identity: {ts.token_string(ts.identity_idx)}")
    print(f"Generators: {[ts.token_string(g) for g in ts.generators]}")

    print("\nElement mapping:")
    for i in range(ts.num_group_elements):
        print(f"  {i}: {ts.token_string(i)}")

    print("\nMultiplication table (rows * cols):")
    header = "   " + " ".join(f"{ts.token_string(j):>4}" for j in range(8))
    print(header)
    for i in range(8):
        row = f"{ts.token_string(i):>3}"
        for j in range(8):
            prod = ts.compose_indices(i, j)
            row += f" {ts.token_string(prod):>4}"
        print(row)

    print("\nTest compositions:")
    # r * r = r²
    print(f"r * r = {ts.token_string(ts.compose_sequence([1, 1]))}")
    # r * r * r * r = e
    print(f"r * r * r * r = {ts.token_string(ts.compose_sequence([1, 1, 1, 1]))}")
    # s * s = e
    print(f"s * s = {ts.token_string(ts.compose_sequence([4, 4]))}")
    # s * r * s = r³ (srs = r⁻¹)
    print(f"s * r * s = {ts.token_string(ts.compose_sequence([4, 1, 4]))}")

    print("\nScan example (s, r, s, r):")
    seq = [4, 1, 4, 1]  # s, r, s, r
    scan = ts.scan_sequence(seq)
    for i, (tok, prefix) in enumerate(zip(seq, scan)):
        print(f"  After {i+1} ops: {ts.format_sequence(seq[:i+1])} = {ts.token_string(prefix)}")
