# 200: Symmetrized Absolute-Value Circulant Preconditioner

**Category**: decomposition
**Gain type**: efficiency
**Source**: Pestana, J. "Preconditioners for Symmetrized Toeplitz and Multilevel Toeplitz Matrices" SIAM J. Matrix Anal. Appl. 40(3):870-887, 2019
**Paper**: [papers/superlinear-band-plus-circulant.pdf]
**Documented**: 2026-02-15

## Description

When solving linear systems $A_n x = b$ with **non-symmetric Toeplitz** coefficient matrices using Krylov methods, convergence analysis is difficult because eigenvalue inclusion regions do not bound convergence for non-symmetric problems. This trick converts the non-symmetric problem into a symmetric one via the **exchange matrix** $Y_n$ (anti-identity / "flip" matrix), then applies an **absolute value circulant preconditioner** to the symmetrized system. The result is that preconditioned MINRES — which has rigorous convergence bounds tied to eigenvalue clustering — can be applied to non-symmetric Toeplitz systems with provable mesh-independent iteration counts.

The key insight is that any non-symmetric Toeplitz matrix $A_n$ can be symmetrized as $Y_n A_n$ (which is a symmetric Hankel matrix), enabling MINRES instead of GMRES. Two ideal preconditioners are proposed:

1. **$A_R = (A_n + A_n^T)/2$** — the symmetric part, which clusters eigenvalues of $A_R^{-1/2}(Y_n A_n) A_R^{-1/2}$ at $\pm 1$ with deviation bounded by $\epsilon < \text{esssup}|f_I/f_R|$
2. **$A_M = A_n(|f|)$** — the Toeplitz matrix generated by $|f|$, which clusters eigenvalues of $A_M^{-1} Y_n A_n$ in $[-1, 1]$ with most near $\pm 1$

Both can be efficiently approximated by circulant matrices (Strang or optimal circulant for $A_R$, **absolute value Strang circulant** $|C_n^{(S)}|$ for $A_M$), preserving $O(n \log n)$ per-iteration cost.

This directly extends the circulant cycle decomposition: the 0th cycle (optimal circulant) approximates $A_R$, while the absolute value circulant captures the spectral modulus $|f|$, providing a principled way to handle non-symmetric Toeplitz systems that arise in causal sequence models.

## Mathematical Form

**Symmetrization via Exchange Matrix:**

The exchange (anti-identity) matrix:

$$
Y_n = \begin{bmatrix} & & 1 \\ & \ddots & \\ 1 & & \end{bmatrix}
$$

converts $A_n x = b$ into the symmetric system:

$$
Y_n A_n x = Y_n b
$$

Since $Y_n A_n = A_n^T Y_n$, the product $Y_n A_n$ is a symmetric Hankel matrix.

**Generating Function Decomposition:**

The Toeplitz matrix $A_n = A_n(f)$ has generating function $f = f_R + if_I$ where $f_R, f_I$ are real-valued. The symmetric part is $A_R = A_n(f_R) = (A_n + A_n^T)/2$.

**Preconditioner $A_R$ — Eigenvalue Clustering (Theorem 3.4):**

$$
A_R^{-1/2}(Y_n A_n) A_R^{-1/2} = Y_n + Y_n E_n
$$

The eigenvalues of the preconditioned matrix lie in $[-1-\epsilon, -1] \cup [1, 1+\epsilon]$ where:

$$
\epsilon < \operatorname{esssup}_{\theta \in [-\pi,\pi]} \left|\frac{f_I(\theta)}{f_R(\theta)}\right|
$$

**Key property:** eigenvalues are bounded away from zero regardless of $\epsilon$, so MINRES converges. When $A_n$ is nearly symmetric ($f_I \approx 0$), $\epsilon \approx 0$ and convergence is very fast.

**Eigenvalue Structure (Theorem 3.4, proof):**

The similarity transform reveals $2 \times 2$ blocks:

$$
Z + \Sigma_k = \begin{bmatrix} 1 & \lambda_k \\ \lambda_k & -1 \end{bmatrix}
$$

with eigenvalues $\pm\sqrt{1 + \lambda_k^2}$, where $\lambda_k$ are eigenvalues of the skew-centrosymmetric error $Y_n E_n$. Hence all eigenvalues satisfy $|\mu| \geq 1$.

**Preconditioner $A_M$ — Absolute Value Preconditioning (Theorem 3.5):**

$$
(A_M)^{-1} Y_n A_n(f) = Y_n A_n(\tilde{f}) + E_n
$$

where $\tilde{f} = f/|f|$ and $\|E_n\|_2 = o(n)$ as $n \to \infty$. The eigenvalues of $Y_n A_n(\tilde{f})$ lie in $[-1, 1]$, clustering at $\pm 1$.

**Absolute Value Strang Circulant Approximation (Theorem 3.6):**

The Strang circulant $C_n^{(S)}$ has eigenvalues $\lambda_j = f(2\pi j/n)$. The absolute value circulant:

$$
|C_n^{(S)}| = F_n^* |\Lambda_n| F_n
$$

where $|\Lambda_n| = \text{diag}(|\lambda_0|, \ldots, |\lambda_{n-1}|)$, satisfies:

$$
|C_n^{(S)}| \to C_n(|f|) \text{ as } n \to \infty
$$

**Key Definitions:**

- $A_n = A_n(f) \in \mathbb{R}^{n \times n}$ — Toeplitz matrix with generating function $f$
- $f = f_R + if_I$ — generating function split into real/imaginary parts
- $Y_n$ — exchange matrix (anti-identity), $Y_n^2 = I_n$
- $A_R = A_n(f_R)$ — symmetric part preconditioner
- $A_M = A_n(|f|)$ — absolute value preconditioner
- $C_n^{(S)}$ — Strang circulant preconditioner
- $|C_n^{(S)}| = F_n^* |\Lambda_n| F_n$ — absolute value Strang circulant
- $F_n$ — DFT matrix, $(F_n)_{j,k} = \frac{1}{\sqrt{n}} e^{2\pi i jk/n}$

## Complexity

| Operation | GMRES (unsymmetrized) | MINRES + $A_R$ | MINRES + $\|C_n^{(S)}\|$ |
|-----------|----------------------|----------------|--------------------------|
| Per-iteration cost | $O(n \log n)$ | $O(n)$ or $O(n \log n)$ | $O(n \log n)$ |
| Iteration count | Unbounded (no theory) | Mesh-independent | Mesh-independent |
| Storage per iteration | $O(kn)$ (k growing) | $O(n)$ (short recurrence) | $O(n)$ (short recurrence) |
| Convergence rate | Unknown | $\epsilon < \|f_I/f_R\|_\infty$ | Clustering at $\pm 1$ |

**MINRES vs GMRES advantage:** MINRES uses only short-term (3-term) recurrences, requiring $O(n)$ storage per iteration regardless of iteration count. GMRES requires storing the entire Krylov basis, costing $O(kn)$ for $k$ iterations.

**Numerical results (from paper, Example 5.1, $f(\theta) = (2 - 2\cos\theta)(1 + i\theta)$):**

| $n$ | GMRES+$C_n$ iters | MINRES+$A_R$ iters | MINRES+$\|C_n\|$ iters | MINRES+$A_R$ time |
|-----|-------------------|-------------------|----------------------|------------------|
| 1023 | 37 | 68 | 82 | 0.029s |
| 2047 | 48 | 68 | 111 | 0.046s |
| 4095 | 62 | 69 | 170 | 0.065s |
| 8191 | — | 72 | — | 0.13s |

$A_R$ with MINRES: **mesh-independent** iteration count (68-72 for all sizes).

**Memory:** $O(n)$ for the circulant preconditioner (first row of length $n$) + $O(n)$ for the MINRES recurrence vectors.

## Applicability

- **Causal/non-symmetric sequence mixing layers**: Toeplitz token mixers in sequence models (e.g., Toeplitz Neural Network) become non-symmetric when causal masking is applied. The symmetrization trick enables efficient iterative solving with provable convergence bounds, unlike GMRES which has no convergence guarantee for non-normal matrices
- **Fractional diffusion operators**: Discretization of fractional PDEs produces non-symmetric Toeplitz systems with generating functions of the form $f(\theta) = \nu + d_+ f_\alpha(\theta) + d_- f_\alpha(-\theta)$ where $f_\alpha(\theta) = -e^{-i\theta}(1 - e^{i\theta})^\alpha$. The symmetrization approach gives mesh-independent iteration counts for these systems
- **Multilevel Toeplitz systems**: The results extend to multilevel (block) Toeplitz matrices arising from multi-dimensional problems (e.g., 2D convolutions), though approximating $A_M$ is more challenging in the multilevel case — block circulant preconditioners may not achieve superlinear convergence
- **Implicit Toeplitz layers during training**: When using implicit differentiation through Toeplitz-structured layers, the backward pass requires solving a Toeplitz system. The symmetrized MINRES approach provides predictable iteration counts for gradient computation
- **Connection to circulant cycle decomposition (Trick 028)**: The 0th circulant cycle of $A_n$ is exactly the optimal circulant approximation, which approximates $A_R$. The absolute value circulant $|C_n^{(S)}|$ captures the spectral modulus across all cycles, providing a complementary view to the multi-cycle approach

## Limitations

- **Near-symmetry assumption for $A_R$**: The preconditioner $A_R$ works best when $\epsilon = \|f_I/f_R\|_\infty$ is small, i.e., the Toeplitz matrix is close to symmetric. For highly non-symmetric matrices (e.g., purely lower-triangular causal masks where $f_I/f_R$ can be large), $A_M$ is preferred but harder to approximate
- **Iterative, not direct**: This is a preconditioning technique for iterative solvers, requiring multiple MINRES iterations. Each iteration involves an FFT for the circulant apply. For small matrices ($n < 1000$), direct methods may be faster
- **$A_M$ construction cost**: The absolute value preconditioner $A_M = A_n(|f|)$ requires computing the Fourier coefficients of $|f|$, which is expensive ($O(n \log n)$ for the generating function evaluation, but computing the Fourier coefficients of $|f|$ from $f$ requires additional work). The Strang absolute value circulant $|C_n^{(S)}|$ is cheaper but approximate
- **GPU friendliness**: MINRES iterations are sequential (each depends on the previous), limiting GPU parallelism. The per-iteration FFT is GPU-friendly, but the iteration loop itself is a sequential bottleneck. Best suited as a "last-mile" solver for moderate-accuracy requirements (residual $\sim 10^{-6}$) rather than high-throughput training kernels
- **Not applicable to dense attention**: This technique assumes Toeplitz structure. Standard softmax attention matrices are neither Toeplitz nor have a known generating function

## Implementation Notes

```python
import torch
import torch.fft as fft


def symmetrize_toeplitz_system(A_col, A_row, b):
    """Symmetrize a Toeplitz system A*x = b via exchange matrix Y_n.

    Instead of solving A*x = b with non-symmetric A,
    solve Y_n*A*x = Y_n*b where Y_n*A is symmetric (Hankel).

    Args:
        A_col: (n,) first column of Toeplitz matrix
        A_row: (n,) first row of Toeplitz matrix
        b: (n,) right-hand side

    Returns:
        Symmetrized system components for MINRES
    """
    n = len(A_col)
    # Y_n * b is just b reversed
    Yn_b = b.flip(0)
    # Y_n * A is a Hankel matrix (symmetric)
    # First row of Y_n*A = last row of A = reversed A_col
    # This is symmetric: (Y_n*A)^T = A^T*Y_n = Y_n*A
    return Yn_b


def absolute_value_strang_circulant(A_col, A_row):
    """Construct the absolute value Strang circulant preconditioner.

    |C_n^(S)| = F_n^* |Lambda_n| F_n

    where Lambda_n are eigenvalues of the Strang circulant.

    Args:
        A_col: (n,) first column of Toeplitz matrix
        A_row: (n,) first row of Toeplitz matrix

    Returns:
        abs_eigs: (n,) absolute values of Strang circulant eigenvalues
    """
    n = len(A_col)
    m = (n - 1) // 2  # Strang: use middle columns

    # Construct Strang circulant first column
    c = torch.zeros(n, dtype=A_col.dtype)
    c[0] = A_col[0]
    for k in range(1, m + 1):
        c[k] = A_col[k]        # lower diagonals
        c[n - k] = A_row[k]    # upper diagonals

    # Eigenvalues of Strang circulant via FFT
    eigs = fft.fft(c)

    # Absolute value circulant: |lambda_j|
    abs_eigs = eigs.abs()

    return abs_eigs


def preconditioned_minres_toeplitz(A_col, A_row, b,
                                    precond='abs_circulant',
                                    tol=1e-8, maxiter=200):
    """Solve non-symmetric Toeplitz system via symmetrized MINRES.

    Solves A_n * x = b where A_n is non-symmetric Toeplitz.
    Uses symmetrization Y_n*A_n*x = Y_n*b and MINRES with
    absolute value circulant preconditioning.

    Args:
        A_col: (n,) first column of Toeplitz A
        A_row: (n,) first row of Toeplitz A
        b: (n,) right-hand side
        precond: 'abs_circulant' or 'symmetric_part'
        tol: convergence tolerance
        maxiter: maximum iterations

    Returns:
        x: (n,) solution
        info: dict with iteration count and residual history
    """
    n = len(A_col)

    # Symmetrized RHS
    Yn_b = b.flip(0)

    # Build preconditioner
    if precond == 'abs_circulant':
        abs_eigs = absolute_value_strang_circulant(A_col, A_row)
        # Preconditioner apply: P^{-1} z = F^* (|Lambda|^{-1}) F z
        def precond_apply(z):
            z_fft = fft.fft(z.to(torch.complex64))
            return fft.ifft(z_fft / abs_eigs.to(torch.complex64)).real
    elif precond == 'symmetric_part':
        # A_R = (A + A^T)/2 is tridiagonal for banded Toeplitz
        # For general case, use circulant approximation of A_R
        sym_col = (A_col + A_row.flip(0)) / 2  # approximate
        sym_eigs = fft.fft(sym_col)
        def precond_apply(z):
            z_fft = fft.fft(z.to(torch.complex64))
            return fft.ifft(z_fft / sym_eigs.to(torch.complex64)).real

    # Toeplitz matvec via FFT (circulant embedding)
    def toeplitz_matvec(x_vec):
        """Compute A_n @ x via circulant embedding."""
        c_embed = torch.zeros(2 * n, dtype=x_vec.dtype)
        c_embed[:n] = A_col
        c_embed[n] = 0
        for k in range(1, n):
            c_embed[2 * n - k] = A_row[k]
        x_embed = torch.zeros(2 * n, dtype=x_vec.dtype)
        x_embed[:n] = x_vec
        result = fft.ifft(
            fft.fft(c_embed.to(torch.complex64)) *
            fft.fft(x_embed.to(torch.complex64))
        ).real[:n]
        return result

    def symmetrized_matvec(x_vec):
        """Compute Y_n * A_n @ x."""
        return toeplitz_matvec(x_vec).flip(0)

    # MINRES with preconditioning (Lanczos-based)
    # Simplified implementation
    x = torch.zeros(n)
    r = Yn_b - symmetrized_matvec(x)
    z = precond_apply(r)

    residuals = []
    for iteration in range(maxiter):
        rnorm = r.norm().item()
        residuals.append(rnorm)
        if rnorm / Yn_b.norm().item() < tol:
            break
        # (Full MINRES would use 3-term Lanczos recurrence here)
        # Simplified: preconditioned CG on the symmetric system
        if iteration == 0:
            p = z.clone()
            rz_old = torch.dot(r, z)
        else:
            rz_new = torch.dot(r, z)
            beta = rz_new / rz_old
            p = z + beta * p
            rz_old = rz_new

        Ap = symmetrized_matvec(p)
        alpha = rz_old / torch.dot(p, Ap)
        x = x + alpha * p
        r = r - alpha * Ap
        z = precond_apply(r)

    return x, {'iterations': iteration + 1, 'residuals': residuals}
```

## References

- Pestana, J. "Preconditioners for Symmetrized Toeplitz and Multilevel Toeplitz Matrices" SIAM J. Matrix Anal. Appl. 40(3):870-887, 2019. DOI: 10.1137/18M1205406
- Pestana, J. & Wathen, A.J. "A Preconditioned MINRES Method for Nonsymmetric Toeplitz Matrices" SIAM J. Matrix Anal. Appl. 36(1):273-288, 2015. DOI: 10.1137/140974213
- Chan, T.F. "An Optimal Circulant Preconditioner for Toeplitz Systems" SIAM J. Sci. Stat. Comput. 9(4):766-771, 1988
- Strang, G. "A Proposal for Toeplitz Matrix Calculations" Stud. Appl. Math. 74(2):171-176, 1986
- Ng, M.K. "Iterative Methods for Toeplitz Systems" Oxford University Press, 2004
- Hariprasad, M. & Venkatapathi, M. "Circulant decomposition of a matrix and the eigenvalues of Toeplitz type matrices" Applied Math. & Computation, 2024 (Trick 028)
